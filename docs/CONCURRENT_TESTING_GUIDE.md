# 高并发测试脚本使用指南

## 概述

`test_concurrent_load.py` 是一个高并发测试脚本，用于测试系统在高并发情况下的表现和潜在问题。

## 安装依赖

```bash
pip install requests
```

## 使用方法

### 1. 混合负载测试（默认）

测试多种操作的混合负载：

```bash
python test/test_concurrent_load.py --base-url http://localhost:5000 --concurrent 50 --requests 1000
```

参数说明：
- `--base-url`: API基础URL（默认: http://localhost:5000）
- `--concurrent`: 并发用户数（默认: 50）
- `--requests`: 总请求数（默认: 1000）

### 2. 库存竞争条件测试

专门测试订单创建时的库存竞争问题：

```bash
python test/test_concurrent_load.py --stock-test --shop-id 1 --product-id 1 --initial-stock 10 --concurrent-orders 20
```

参数说明：
- `--stock-test`: 启用库存测试模式
- `--shop-id`: 店铺ID
- `--product-id`: 产品ID
- `--initial-stock`: 产品的初始库存
- `--concurrent-orders`: 并发创建的订单数

## 测试场景

### 1. 订单创建（库存竞争条件）

**测试目的**: 检测在高并发情况下，多个用户同时购买同一产品时，库存是否正确扣减。

**可能发现的问题**:
- ✅ **库存超卖**: 成功订单数超过实际库存
- ✅ **数据库死锁**: 多个事务同时更新同一产品库存导致死锁
- ✅ **数据不一致**: 订单创建成功但库存未正确扣减
- ✅ **性能瓶颈**: 订单创建响应时间过长

**影响**:
- 商家可能面临库存超卖，需要手动处理订单
- 用户体验差，订单可能失败
- 数据库性能下降，可能导致系统崩溃

### 2. 产品查询（读取压力）

**测试目的**: 测试系统在高并发读取请求下的性能表现。

**可能发现的问题**:
- ✅ **响应时间过长**: 查询响应时间超过可接受范围
- ✅ **数据库连接池耗尽**: 连接数不足导致请求失败
- ✅ **缓存失效**: 缓存未正确配置导致数据库压力过大
- ✅ **N+1查询问题**: 关联查询未优化导致性能下降

**影响**:
- 用户浏览产品时响应缓慢
- 系统资源消耗过高
- 可能导致数据库连接超时

### 3. 用户登录（认证压力）

**测试目的**: 测试认证系统在高并发登录请求下的表现。

**可能发现的问题**:
- ✅ **Session管理问题**: Session存储压力过大
- ✅ **密码验证性能**: bcrypt哈希计算在高并发下成为瓶颈
- ✅ **数据库查询压力**: 用户查询未优化
- ✅ **认证失败率上升**: 系统负载过高导致正常登录失败

**影响**:
- 用户无法正常登录
- Session存储可能溢出
- 系统响应变慢

### 4. 购物车操作

**测试目的**: 测试购物车相关操作在高并发下的表现。

**可能发现的问题**:
- ✅ **数据竞争**: 多个请求同时修改购物车
- ✅ **Session冲突**: Session存储冲突
- ✅ **性能问题**: 购物车查询响应慢

**影响**:
- 购物车数据可能丢失或错误
- 用户体验差

### 5. 积分交易（数据一致性）

**测试目的**: 测试积分系统在高并发交易下的数据一致性。

**可能发现的问题**:
- ✅ **积分重复扣除**: 同一订单多次扣除积分
- ✅ **积分计算错误**: 并发下积分计算不准确
- ✅ **事务问题**: 积分交易未正确使用事务

**影响**:
- 用户积分可能错误
- 财务数据不准确
- 用户信任度下降

## 测试结果分析

脚本会生成以下统计信息：

1. **成功率**: 成功请求占总请求的百分比
2. **响应时间统计**: 平均、最小、最大响应时间
3. **错误信息**: 失败请求的错误详情
4. **QPS**: 每秒处理的请求数

### 结果文件

测试完成后会生成JSON格式的结果文件：`test_results_YYYYMMDD_HHMMSS.json`

## 常见问题及解决方案

### 1. 库存超卖问题

**问题**: 成功订单数超过实际库存

**解决方案**:
- 使用数据库行级锁（SELECT ... FOR UPDATE）
- 使用乐观锁（版本号机制）
- 使用Redis分布式锁
- 在应用层添加库存检查

### 2. 数据库连接池耗尽

**问题**: 数据库连接数不足

**解决方案**:
- 增加数据库连接池大小
- 优化查询，减少连接占用时间
- 使用连接池监控工具
- 实现连接超时和重试机制

### 3. 响应时间过长

**问题**: 平均响应时间超过可接受范围

**解决方案**:
- 优化数据库查询（添加索引）
- 使用缓存（Redis）
- 优化N+1查询问题
- 使用数据库读写分离
- 添加CDN加速静态资源

### 4. Session存储问题

**问题**: Session存储压力过大

**解决方案**:
- 使用Redis存储Session
- 减少Session数据大小
- 实现Session过期机制
- 使用JWT替代Session

## 性能基准建议

根据系统规模，建议的性能指标：

| 指标 | 小型系统 | 中型系统 | 大型系统 |
|------|---------|---------|---------|
| QPS | 100+ | 1000+ | 10000+ |
| 平均响应时间 | <200ms | <100ms | <50ms |
| 成功率 | >99% | >99.9% | >99.99% |
| 并发用户数 | 50-100 | 500-1000 | 5000+ |

## 注意事项

1. **测试环境**: 建议在测试环境运行，避免影响生产数据
2. **数据库备份**: 测试前备份数据库，测试后可能需要恢复
3. **资源监控**: 测试时监控服务器CPU、内存、数据库连接数等
4. **逐步增加**: 从低并发开始，逐步增加并发数
5. **真实数据**: 使用接近生产环境的数据量进行测试

## 示例输出

```
============================================================
开始混合负载测试
============================================================
基础URL: http://localhost:5000
并发用户数: 50
总请求数: 1000
开始时间: 2024-01-15 10:30:00

============================================================
测试结果汇总
============================================================
总耗时: 45.23 秒
总请求数: 1000
平均QPS: 22.11

product_query:
  总请求: 750
  成功: 745 (99.33%)
  失败: 5
  平均响应时间: 45.23ms
  最小响应时间: 12.34ms
  最大响应时间: 234.56ms

user_login:
  总请求: 250
  成功: 248 (99.20%)
  失败: 2
  平均响应时间: 67.89ms
  最小响应时间: 23.45ms
  最大响应时间: 345.67ms

详细结果已保存到: test_results_20240115_103045.json
```

## 进一步优化建议

1. **添加监控**: 集成Prometheus/Grafana监控
2. **压力测试**: 使用Locust或JMeter进行更专业的压力测试
3. **数据库优化**: 分析慢查询日志，优化数据库性能
4. **缓存策略**: 实施Redis缓存策略
5. **负载均衡**: 使用Nginx或HAProxy进行负载均衡
6. **数据库读写分离**: 分离读写操作，提高性能

